## 자영업자와 종업원을 위한 사업장 관리 애플리케이션, Beitool

### Goal 
- 수기로 작성되는 등 사업장 관리 편의성 증가
- 자영업자와 종업원 간 수직적인 구조로 인한 업무 비효율 개선

### Tech
`Spring boot` `JPA` `MySQL` `AWS EC2` `AWS RDS` `AWS S3`  

### Description

<details>
    <summary><b>1. Beitool 프로젝트 제안서</b></summary>
<div markdown="1">
    
### 💥자영업자를 위한 업장 관리 애플리케이션 Beitool💥
### 1. **개요**

1. 사업장을 운영하는 대부분의 업주가 종업원의 정보를 수기로 관리한다.
2. 기존에 사용하던 카카오톡 등 개인 메신저는 업무 시간 외 과도한 메신저 지시 및 사생활 침해 우려가 있다. 또한, 사적인 용도로 사용하는 사람들이 있다.
3. 새로운 종업원이 들어올 때마다 구두로 인수인계를 한다. 사업장이 클수록, 새로운 알바생은 이를 까먹거나 헷갈릴 수 있다. 바쁜 상황에서 사소한 실수가 자주 발생하고 드물게 큰 문제가 발생하는 경우가 있다.
4. 인수인계 사항이 발생할 경우, 모든 종업원에게 전파되지 못하는 경우가 자주 발생한다.
5. 최저시급이 증가했기 때문에 종업원의 업무 효율을 높일 필요가 있다.

---

### 2. **목표 및 기대효과**

1. 기존 수직적인 구조에서 수평적인 구조로 원활한 소통이 가능한 업장 관리
2. 공과 사를 구분하여 사업장과 관련된 일은 우리 어플을 통해서 관리할 수 있다.
3. 사업장을 운영하는 도중 발생하는 일을 기록하고, 이를 근거로 급여를 산정 및 이벤트를 처리한다.
4. 가이드라인을 제시해 새로운 종업원이 빠르게 적응할 수 있도록 돕는다.
5. 인수인계 사항을 모든 종업원에게 전파하여 문제가 발생하지 않도록 한다.
6. 캘린더 기능을 제공해 사업장의 스케줄을 관리하고 종업원들이 인지할 수 있도록 한다.
7. 업무 효율성 극대화 및 인력 낭비 최소화

---

### 3. **서비스 대상**

1. 사업장을 운영하는 업주

    - 여러 개의 사업장을 관리하는 업주  
    - 사업장에 종업원만 두고 사업장을 운영하는 업주

  b. 사업장에 종사하는 종업원  
  c. 그 외 사업장과 관련된 인원

---

### 4. **기능**

1. 업주/종업원 구분(직급)을 위한 회원관리 (소셜 로그인)
2. 채널을 나누어 알바생을 초대한다.
3. 출/퇴근 관리 (GPS)
4. 공지사항 및 업무 지시를 위한 게시판(업주) 및 완료 표시(종업원)
5. 일정 관리를 위한 캘린더
6. 급여 계산기 개인
7. 채팅, 단체 채팅이 가능하다. (채팅)

---

### 5. **시나리오**

1. 업주는 종업원 고용하고 우리 사업장에 가입한다.
2.  GPS를 통해 종업원이 업장에 들어올 경우 출근 버튼을 눌러 출근을 한다. 일이 끝나고 퇴근할 때도 퇴근 버튼을 눌러 퇴근한다. 업주는 출퇴근 기록을 통해 급여를 산정할 수 있다.
3. 업주는 사업장 메뉴얼 및 공지사항을 게시판 형태로 작성할 수 있다. 새로운 종업원은 업무가 헷갈릴 경우, 사업장 메뉴얼을 확인해 정확한 업무를 수행한다.(게시판)
4.  (종업원)특이사항 및 변동사항이 발생할 경우, 단체 채팅방에 이를 알리고, 인수인계 사항을 작성한다.
5.  업주는 종업원 별로 개인 업무를 지시해 기록할 수 있고, 종업원은 수행 후 완료 표시를 한다.
6.  종업원은 현재 받아야할 급여가 얼마인지 확인할 수 있다.
    <hr>

    </div>
</details>

<details>
<summary><b>2. 요구사항 도출</b></summary>
    <div markdown="1">
        <li> 시나리오를 통해 요구사항을 도출하고 간단한 프로토타입을 작성했습니다.</li>
        <li>예상되는 고객층인 주변 사업장에 직접 방문하여 인터뷰를 진행하여 요구사항을 도출하였습니다.</li>
        <li> 사업장이 운영되는 프로세스에 대한 흐름과 실제 필요한 서비스에 대한 분석을 할 수 있었습니다.</li> 
        <br>
        <a href="https://docs.google.com/document/d/1bTl9Ts1bFiJXYVZBmmt_4RRsX8_jwH6X/edit?usp=sharing&ouid=104955200740988354269&rtpof=true&sd=true">:point_right:요구사항 도출 결과:point_left:</a>
    </div>
</details>

<details>
    <summary> <b>3. 와이어 프레임</b> </summary>
    <div markdown="1">
        <li>팀원 간 원할한 소통과 이해를 돕기 위한 와이어 프레임입니다.</li>
        <li>개발 과정에서 많은 도움이 되었습니다.</li>
<br>
<a href="https://miro.com/app/board/uXjVOHIkCfk=/">:point_right:와이어 프레임 전체 보기(Miro):point_left:</a>  
<p align=center><와이어 프레임 일부></p>
<img src = "https://user-images.githubusercontent.com/77626299/168792110-c5abceca-20f5-43f1-be4e-dbffec47c393.png" width="480px" height="480px">
&nbsp;<img src = "https://user-images.githubusercontent.com/77626299/168792833-e33f7d6c-ae16-4d9e-8ad2-cb849fb298c1.png" width="520px" height="480px">  
    
</div>
</details>

<details>
    <summary><b>4. ER 모델</b></summary>
<div markdown="1">
    효율적인 DB 설계를 위한 ER 모델입니다.  
    사용자가 많아졌을 때, 테이블의 크기와 조회 빈도를 고려하여 설계하였습니다.
    <br>
    <a href="https://www.erdcloud.com/d/jWMmwwkNTojueJHRS">:point_right:ER 모델 전체 보기(ERDCLOUD):point_left:</a>    
    <br>
    <br>
    <전체 구조>  <br>
    
<img src = "https://user-images.githubusercontent.com/77626299/168794105-1f0c7fad-1a2b-418c-a87b-1f8f706e5b8c.png" width="50%" height="50%">

</div>
</details>

<details>
    <summary><b>5. 리팩토링</b></summary>
<div markdown="1">  

<br>

제한된 개발 기한으로 인해 쌓여있는 **기술 부채 해소**를 위한 리팩토링 과정입니다.  
근거를 갖고, 완성도 있는 프로그램으로 나아가려 노력하고 있습니다.
    <details>
        <summary><b>5-1. Builder 패턴</b></summary>
    <div markdown="1">
## 상황

엔티티와 DTO 객체 생성할 때 생성자를 활용했다. 특히, 엔티티의 경우 Setter의 사용을 최대한 지양했다.   
**:question:Setter를 지양하고 생성자를 활용한 이유**

- 무분별한 Setter 사용으로 엔티티의 값이 **외부에서 임의로 변경되는 것**을 방지
→ 수정 가능성을 닫는다(Open-closed 원칙)
- 값이 변경되는 시점을 확실히 해 유지보수성을 높임   

**문제점**
- 꼭 필요한 인자를 빼고 객체를 생성하는 상황에 대비해, 따로 검증하는 단계가 필요하다.
- 일부 인자만을 포함한 객체를 생성하기 위한 생성자를 구현해야 한다.
- 매개변수를 잘못 넣거나, 순서가 달라지는 실수를 할 수 있다.
- 컴파일 단계에서 실수를 잡을 수 없어, 런타임 에러로 이어진다.

특히, 일부 DTO의 경우 같은 데이터 타입을 가진 인자가 많아, 개발 과정에서 실수를 많이 했다.   
이를 `Builder 패턴을 활용해 코드를 개선할 수 있었다.`   

## 변경 전
변경된 코드의 예시 - **재고관리 도메인(엔티티)**    

- 재고관리 도메인(`Stock`)은 총 8개의 인자와 부모 클래스(`BoardDomain`)에게 상속 받는 6개의 인자가 있다.  
+ String 4개, LocalDateTime 2개, Long 2개, Integer 1개, member 1개, Store 1개, boolean 1개

생성자 코드   
<img src = "https://user-images.githubusercontent.com/77626299/178258417-dd1b99ea-ed40-487e-8b14-281f4576acb1.png" width="50%" height="50%">

서비스 레이어의 객체 생성 코드   
<img src = "https://user-images.githubusercontent.com/77626299/178258565-496cd01b-1147-40dc-aed5-2cbbe3816f41.png" width="50%" height="50%">

같은 데이터 타입을 가진 인자가 많아, 순서를 잘못 넣어도 실행해 값을 확인하기 전까지 알 수 없다.   
실제로, 객체를 생성하는 과정에서 실수가 없는지 여러 번 확인한 기억이 있다.

## 변경 후
Builder 패턴 적용 후 객체 생성 코드   
<img src = "https://user-images.githubusercontent.com/77626299/178259519-5347d470-12e3-4a69-926e-4d10c150d06e.png" width="40%" height="40%">   

Builder를 적용하면서 Request DTO의 값을 바로 넣으면 코드의 길이를 더 줄일 수 있다.   
하지만, Response DTO를 작성하는 과정에서 재사용 되기 때문에, 지역 변수로 선언하여 적용했다.   

### 결과
- 객체 생성 과정에서, 잘못된 매개변수를 넣어도 컴파일 단계에서 실수를 바로잡을 수 있다.
- 각 인자에 어떤 값이 들어가는지 한 눈에 볼 수 있다.

    </div>
</details>
    
<details>
    <summary><b>5-2. 회원가입/로그인과 JWT 토큰</b></summary>
<div markdown="1">   

## 기존 회원가입/로그인 로직(진행중)

### - 엑세스 토큰이 유효한 경우

1. 클라이언트로부터 엑세스토큰과 리프레시 토큰을 받는다.
2. `MemberKakaoApiService.getTokenInfo()`에서 HTTP 메시지를 카카오로 전달해서 토큰 정보를 받는다.
3. `checkNewMember()` 메소드를 호출해, 카카오의 회원번호를 통해 DB에서 회원을 조회해 기존 회원과 신규 회원을 구분한다.
4. 신규 회원은 회원 번호와 함께 새로운 회원을 추가한다. 기존 유저의 경우 화면만 이동하도록 한다.

→ 카카오 API 호출 1회, DB 접근 1회

### - 엑세스 토큰이 유효하지 않은 경우

1. 엑세스 토큰이 유효하지 않은 경우(혹은 유효 시간이 10분 미만으로 남은 경우), -401 코드와 함께 `UNAUTHORIZED` 예외가 발생해 컨트롤러로 이동한다.
2. 엑세스 토큰의 만료 시간이 10분 미만인 경우에도 `UNAUTHORIZED`예외를 고의로 발생시켜 컨트롤러의 catch문으로 넘긴다.
3. `memberRepository.findByRefreshToken()` 메소드에서 리프레시 토큰을 사용해 회원을 조회한다.  
(기존 회원은 DB에 리프레시토큰이 남아있기 때문이다.) 
4. 이마저도, `NoResultException`이 발생하면, catch문으로 이동해 다시 로그인 화면으로 이동하게 한다.
5. 리프레시 토큰을 통한 회원 조회에 성공하면, 다시 한 번 `getTokenInfo()` 메소드를 통해 정보를 전달 받는다.

## 문제점

- **구조**
    - `try-catch` 문이 너무 난잡하게 사용되고 있다. → 예외 처리를 깔끔하게 못하고 있다.
    - 최악의 경우, HTTP 메시지를 2번 전송해야 한다.
    - 코드의 가독성이 매우 떨어진다.
- **DTO**
    - 클라이언트에게 전달 받기 위한 RequestDTO를 Response에도 사용한다.
    - 한 DTO안에 포함된 필요 없는 정보가 너무 많다.
- **성능**
    - **API를 사용하기 위한 인증 시, 항상 토큰을 전달받는다.**  
    → 불가피하게, 카카오와 HTTP 통신을 한 번 이상 꼭 해야한다.  
    ⇒ 카카오에 의존성이 너무 높다. (카카오에 문제가 생기면 서비스 전체를 사용못함)
    - 한 개의 엔드포인트에서 로그인·토큰 재발급·재발급 후 로그인 시도 등 너무 많은 기능이 한 메소드에 몰려있다.  
    → 경우에 따른 성능이 떨어질 수밖에 없다.

## 해결책

- 한 개의 엔드 포인트에서 모든 절차를 해결하려 하지 않고, 클라이언트에서 HTTP Status를 활용해 상황에 따른 대처를 할 수 있도록 한다.
- 전체적인 구조를 분리해 가독성을 높인다.
- 로그인 이후, **자체적인 토큰을 발급**해 데이터를 관리해 외부 통신을 계속 하지 않게 한다.
- Spring Security를 사용해 서버 접근 전에 인증/인가를 진행한다.

### 근거

최초 웝업(Warm-Up)단계에서 오래 걸리는 시간을 제외하고 테스트를 진행했다.   
|-|변경 전|변경 후|
|------|---|---|
|토큰이 유효한 경우|79.7ms (65~101ms)|-|
|토큰이 유효하지 않은 경우|24.7ms (11~95ms)|-|
|재발급 받는 경우|183.4 (171~193ms)|-|   

</div>
</details>
